# Logistic Regression and Friends

This chapter is about regression models for *binary outcomes*, models in which our outcome of interest $Y$ takes on one of two mutually exclusive values: yes/no, smoker/non-smoker, default/repay, etc. By convention we code one of the two possibilities as a "success," assigning it the value `1`, and the other a "failure," assigning it the value `0`. Here's a simple and entertaining example. I recently asked my MPhil students at Oxford to play a game called "two truths and a lie."^[This example was devised by [Andrew Gelman](http://www.stat.columbia.edu/~gelman/research/published/truths_paper.pdf). For more in-class examples and experiments, I highly recommend [Teaching Statistics: A Bag of Tricks](http://www.stat.columbia.edu/~gelman/bag-of-tricks/).] The class divided into groups of four, and we then took it in turns to make three statements to the other members of our groups: two true statements, and one lie. The remaining three group members were tasked with determining which statement was a lie and assigning an overall "certainty score" ranging from zero (just guessing) to ten (completely certain). So how accurate are these subjective certainty scores? This question amounts to asking how the probability of *guessing correctly*, $Y = 1$, varies with the certainty score, $X$. 

Our task in this lesson will be propose, interpret, and estimate regression models for the probability that $Y= 1$ given $X$, where $X$ is a vector of one or more predictor variables. While $Y$ is binary, $X$ could be continuous, discrete, or a mix of the two. Models like this *can* be used for causal inference, but for now we will scrupulously avoid using any causal language. Our problem for the moment is simply to predict $Y$. A natural question is "why not just use linear regression?" Indeed this is one possibility, as we'll discuss below. The fundamental problem is that lines have the same slope *everywhere*: they keep going up or down forever at the same rate. Probabilities, on the other hand, are bounded between zero and one. If we want a regression model that is guaranteed to make predictions in this range, it *can't* be linear. 

Our main focus in this lesson will be *logistic regression*, far and away the most popular model for binary outcomes. Towards the end, we'll briefly discuss *probit regression.* Each of these is an example of an *index model,* a model of the form $P(Y=1|X) = G(X'\beta)$ where $G(\cdot)$ is known function. Roughly speaking, the idea is to stick our usual linear regression predictor $X'\beta$ inside a function $G(\cdot)$ that makes predictions on the right scale. For logistic regression $G(z) = \texttt{plogis}(z)$ the [standard logistic CDF](https://en.wikipedia.org/wiki/Logistic_distribution); for probit regression $G(z) = \texttt{pnorm}(z)$, the standard normal CDF. Setting $G(\cdot)$ equal to a CDF ensures that our predictions will indeed lie between zero and one!

Compared to the usual treatment of logistic regression in econometrics, we will devote *much more time* to understanding the meaning of the model and much less time to technical details. This is because I assume that your econometrics course likely took the *opposite approach*. If you're hankering for more technical details, or if you want to brush up on the basic details of logistic regression, you can view my [MPhil teaching materials here](https://www.economictricks.com/). 

## Understanding the Logistic Regression Model

From a purely probabilistic perspective, there are two equivalent ways of thinking about logistic regression:
$$
P(Y=1|X) = \texttt{plogis}(X'\beta) \quad \iff \quad \log \left[\frac{P(Y=1|X)}{P(Y=0|X)}\right] = X'\beta.
$$
The first of these expresses the *probability* that $Y=1$ given $X$ as a nonlinear function of data and parameters; the second expresses the *log odds* that $Y=1$ given $X$ as a linear function of data and parameters.^[When I write log in this book, unless I explicitly say otherwise this is the *natural log*, following R's usage: `log()` defaults to natural log unless you specify `base = [YOUR PREFERRED BASE HERE]`.] This means that we can either think of logit regression as an index model for $P(Y=1|X)$ or as a linear regression model for the *log odds*. Many people, even those with extensive training in probability, find odds to be a slightly strange concept. In fact odds, and especially log odds, are very natural.^[Pun intended!] If you'll permit a short digression, I'd like to take this opportunity to change your mind about odds. 

### Odds aren't so odd!

Forget about regression for the moment and consider some event $A$ with probability $p$ of occurring. Then we say that the **odds** of $A$ are $p/(1 - p)$. For example, if $p = 1/3$ then the event $A$ is equivalent to drawing a red ball from an urn that contains one red and two blue balls: the probability is the *ratio of red balls to total balls*. The odds of $A$, on the other hand, are $(1/3) / (2/3) = 1/2$: the odds is the *ratio of red balls to blue balls*. Viewed from this perspective, there's nothing inherently more intuitive about probabilities compared to odds. We're simply more familiar with probabilities. 

But perhaps you're still not convinced. Here's an example that you've surely seen before:

> One in a hundred women has breast cancer $(B)$. If you have breast cancer, there is a 95\% chance that you will test positive $(T)$; if you do not have breast cancer $(B^C)$, there is a 2\% chance that you will nonetheless test positive $(T)$. We know nothing about Alice other than the fact that she tested positive. How likely is it that she has breast cancer?

It's easy enough to solve this problem using Bayes' Theorem, as long as you have pen and paper handy: 
$$
\begin{aligned}
P(B | T) &= \frac{P(T|B)P(B)}{P(T)} = \frac{P(T|B)P(B)}{P(T|B)P(B) + P(T|B^C)P(B^C)}\\
&= \frac{0.95 \times 0.01}{0.95 \times 0.01 + 0.02 \times 0.99} \approx 0.32.
\end{aligned}
$$
But what if I asked you how the result would change if only one in a thousand women had breast cancer? What if I changed the [sensitivity](https://en.wikipedia.org/wiki/Sensitivity_and_specificity) of the test from 95\% to 99\% or the [specificity](https://en.wikipedia.org/wiki/Sensitivity_and_specificity) from 98% to 95\%? If you're anything like me, you would struggle to do these calculations in your head. That's because $P(B|T)$ is a *highly non-linear* function of $P(B)$, $P(T|B)$, and $P(T|B^C)$.

In contrast, working with odds makes this problem a snap. The key point is that $P(B|T)$ and $P(B^C|T)$ have the same denominator, namely $P(T)$:
$$
P(B | T) = \frac{P(T|B)P(B)}{P(T)}, \quad
P(B^C | T) = \frac{P(T|B^C)P(B^C)}{P(T)}
$$
Notice that $P(T)$ was the "complicated" term in $P(B|T)$; the numerator was simple. Since the odds of $B$ given $T$ is defined as the ratio of $P(B|T)$ to $P(B^C|T)$, the denominator cancels and we're left with 
$$
\text{Odds}(B|T) \equiv \frac{P(B|T)}{P(B^C|T)} = \frac{P(T|B)}{P(T|B^C)} \times \frac{P(B)}{P(B^C)}.
$$
In other words, the *posterior odds* of $B$ equal the *likelihood ratio*, $P(T|B)/P(T|B^C)$, multiplied by the *prior odds* of $B$, $P(B)/P(B^C)$:
$$
\text{Posterior Odds} = \text{(Likelihood Ratio)} \times \text{(Prior Odds)}.
$$
Now we can easily solve the original problem in our head. The prior odds are 1/99 while the likelihood ratio is 95/2. Rounding these to 0.01 and 50 respectively, we find that the posterior odds are around 1/2. This mean's that Alice's chance of having breast cancer is roughly equivalent to the chance of drawing a red ball from an urn with one red and two blue balls. There's no need to convert this back to a probability since we can already answer the question: it's considerably more likely that Alice *does not* have breast cancer. But if you insist, odds of 1/2 give a probability of 1/3, so in spite of rounding and calculating in our heads we're within 0.3\% of the exact answer!

Repeat after me: **odds are on a multiplicative scale**. This is their key virtue and the reason why they make it so easy to explore variations on the original problem. If one in a thousand women has breast cancer, the prior odds become 1/999 so we simply divide our previous result by 10, giving posterior odds of around 1/20. If we instead changed the sensitivity from 95\% to 99\% and the specificity from 98\% to 95\%, then the likelihood ratio would change from $95/2 \approx 50$ to $99/5 \approx 20$. It's also easy to work out the effect of conditioning on additional sources of information. To compute the posterior odds after a *second* positive test result with the same sensitivity and specificity as the first and conducted independently of it, simply multiply by the likelihood ratio a *second time*. This is worth repeating: each positive test result has the effect of multiplying the prior odds by the *same factor*.  

Since odds are on a multiplicative scale, **log odds are on an additive scale** 
$$
\log(\text{Posterior Odds}) = \log\text{(Likelihood Ratio)} + \log\text{(Prior Odds)}.
$$
Base 2 logarithms are simplest for computers, natural logarithms are simplest for mathematics, and base 10 logarithms are simplest for human beings. So for a moment let's think in base 10. A good diagnostic test might have a sensitivity and specificity of around 90\%; an better one might have values of 99\%; an excellent one might have values of around 99.9\%. These translate into likelihood ratios of 9, 99, and 999 respectively. On a log base ten scale these are approximately 1, 2, and 3. A common disease might have a prevalence of 10\%; a rarer one 1\%; and an even rarer one 0.1\%. Expressed as prior odds, these values become  1/9, 1/99, and 1/999 or -1, -2, and -3 on the log base 10 scale. The log posterior odds are simply the *sum* of these two numbers. For example, a sensitivity and specificity of 10\% and a prevalence of 1\% gives log odds of approximately $1 - 2 = -1$. This means that the odds of having the disease are around $1/10$. A second positive result multiplies the odds by the likelihood ratio a second time. On the log scale this means adding 1, yielding log odds of 0 and odds of 1/2. This kind of reasoning is extremely helpful for quick, back-of-the-envelope calculations about how much to change our views in the light of new evidence. It's also *extremely* helpful for understanding logistic regression. But before returning to our regularly-scheduled programming, here are a few exercises to test your understanding.

### Exercise
1. I haven't given you a closed-form expression for `plogis()`. Use the log-odds representation of logit regression to work out an explicit formula. And create a function called `myplogis()` that implements this in R. Check that your function gives the same results as the "real" `plogis()` function on a grid of 100 equally spaced points between -3 and 3.
2. Exercise: probabilities are between 0 and 1. What about odds? What about log odds? 
3. If the probability of an event is $1/2$, what are the odds? What about the log odds? What does this tell us about the qualitative interpretation of odds and log odds?
4. Bayes on the odds scale for independent tests, arbitrary number of positive and negative test results.

### Interpreting a Simple Logit Regression Model

To summarize our digression and exercises from above: probabilities are mathematically inconvenient because they're bounded above and below. This is the reason for the non-linearity in Bayes' Theorem expressed on the probability scale. In contrast, odds are simpler: they're *multiplicative*, bounded below by zero, and unbounded above. Odds of one mean $A$ and $A^C$ are equally likely. Log odds are even simpler: they're additive and unbounded. Log odds of zero mean that $A$ and $A^C$ are equally likely. Now it's time to use this knowledge to help us understand logistic regression. Our goal is to understand how changing $x$ affects $P(Y=1|X=x)$ under the model.

Let's start with the simplest possible example: $p(x) \equiv P(Y=1|X=x) = \texttt{plogis}(\alpha + \beta x)$ where $X$ is a scalar. What is the derivative of $p(x)$ with respect to $x$? By the chain rule,
$$
\frac{d}{dx} \texttt{plogis}(\alpha + \beta x) = \beta \times \texttt{dlogis}(\alpha + \beta x) 
$$
where $\texttt{dlogis}(\cdot)$ is the standard logistic density. Since $\texttt{dlogis}(\cdot)$ is a density it can't be negative, so the derivative has the same sign as $\beta$. Its magnitude, however, depends on the value of $x$ at which we evaluate it *and* on the value of $\alpha$. On the *probability scale*, partial effects for logit regression are *non-linear*. Because it's a CDF, $\texttt{plogis}(\cdot)$ eventually "flattens out." Increasing $x$ by one unit therefore cannot have the same effect on $P(Y=1|X=x)$ when the baseline value of $x$ as it does when the baseline value is high. 

As above, everything's easier with odds. As you'll show in the exercise below,
$$
\frac{\texttt{plogis}(z)}{1 - \texttt{plogis}(z)} = \exp(z) \implies
\text{Odds}(Y=1|X=x) = \exp(\alpha + \beta x)
$$
Therefore, increasing $x$ by one unit is equivalent to multiplying the *odds* that $Y=1$ by $\exp(\beta)$. This holds true *regardless* of the values of $\alpha$ or $x$.

### Exercise
1. In the simple model abvoe, suppose that 
2. Divide by four rule
3. Average partial effect versus partial effect at average




## Odds and Ends about Risk
![](https://imgs.xkcd.com/comics/spacecraft_debris_odds_ratio.png)



## The Latent Data Formulation of Logistic Regression
Another way to think about logistic regression is via the following *generative model*:
\[
 y_i^* = X_i'\beta + \epsilon_i, \quad
 y_i = \left\{ \begin{array}{cc}
 1 & \mbox{if } y^*_i > 0\\
 0 & \mbox{if } y^*_i \leq 0\\
 \end{array}\right., \quad
 \epsilon_i \sim \mbox{ iid Logistic}(0,1) 
\]
where the Logistic$(0,1)$ distribution has CDF $\Lambda(z) = e^z/(1 + e^z)$ and pdf $\lambda(z) = e^z/(1 + e^z)^2$.
The expressions $\Lambda$ and $\lambda$ should look familiar, since we worked with them above.
We call this a generative model because it tells us how to *generate* the observations $y_i$ using the regressors $X_i$.
If we want to *simulate* data from a logistic regression model, the latent data formulation gives us a convenient way to do so.

The idea behind the latent data formulation is that a continuous *unobserved* random variable $y_i^*$ determines whether the *observed* binary random variable $y_i$ is zero or one.
The term *latent* is just a synonym for unobserved.
While this may seem odd, in specific examples we can often give $y_i^*$ a meaningful interpretation.
For example, suppose that $y_i=1$ if person $i$ voted for Hilary Clinton in the 2016 presidential election and $X_i$ contains demographic information, e.g.\ income, education, race, sex, and age.
The latent variable $y_i^*$ can be viewed as a measure of person $i$'s *strength of preference* for Hilary Clinton relative to Donald Trump.
If $y^*_i$ is large and positive, person $i$ strongly prefers Clinton; if $y_i^*$ is large and negative, person $i$ strongly prefers Trump; if $y_i^* = 0$, person $i$ is indifferent.

### Exercise \#3
(a) Show that $\lambda(z)$ is symmetric about zero, i.e. $\lambda(z) = \lambda(-z)$.
(b) Show that the latent data formulation implies $\mathbb{P}(y_i = 1) = \Lambda(X_i'\beta)$. Hint: if $Z$ is a continuous RV with a pdf that is symmetric about zero, then $\mathbb{P}(-Z<c) = \mathbb{P}(Z\leq c)$.

## Solution to Exercise \#3
<!-- ANS_START -->
(a) Expand the denominator, and then multiply by $\exp(-2z)/\exp(-2z)$, yielding
\[
\lambda(x) = \frac{\exp(z)}{[1 + \exp(z)]^2} = \frac{\exp(z)}{1 + 2\exp(z) + \exp(2z)} = \frac{\exp(-z)}{\exp(-2z) + 2\exp(-z) + 1} = \frac{\exp(-z)}{[1 + \exp(-z)]^2} = \lambda(-z)
\]
(b) $\mathbb{P}(y_i = 1) = \mathbb{P}(y_i^* > 0) = \mathbb{P}(X_i'\beta + \epsilon_i > 0) = \mathbb{P}(-\epsilon_i < X_i'\beta) = \mathbb{P}(-\epsilon_i \leq X_i'\beta) = \Lambda(X_i'\beta)$
<!-- ANS_END -->


## Part II - Logistic Regression in R
Now we'll take a quick look at how to carry out logistic regression in R using a simulated dataset.
In Thursday's lab you'll use what you learn in this part to study a real-world example.

## Simulating Data from a Logistic Regression
The R function `rlogis` creates iid draws from the logistic distribution.
If we only specify one argument, `rlogis` assumes that this is the number of random draws that we wish to make, and sets the values of its *location* and *scale* parameters to 0 and 1, respectively.
This is what we want, since these parameters correspond to the Logistic$(0,1)$ distribution that appears in the latent data formulation from above.
Using `rlogis`, we can simulate data from a logistic regression model as follows: 
```{r}
set.seed(1234)
n <- 500
b0 <- 0.5
b1 <- 1
x <- rnorm(n, mean = 1.5, sd = 2)
ystar <- b0 + b1 * x + rlogis(n)
y <- 1 * (ystar > 0)
mydat <- data.frame(x, y)
```

### Running a Logistic Regression in R
We can now run a logistic regression use the simulated dataset `mydat` to carry out logistic regression.
Note that in a certain sense this is silly: we generated the data so we *know* the true values of $\beta_0$ and $\beta_1$. 
Why bother carrying out logistic regression to *estimate* them?
There are two answers to this question.
First, this is only an example: don't be so picky!
Second, it can be extremely valuable to work with simulated data to check whether our statistical methods are working correctly.
If we *know* for sure that the data came from a logistic regression model, then our logistic regression estimates should be close to the truth. 
If they're not, then something is wrong with our computer code.

The R function `glm` can be used to carry out logistic regression.
The name of this function is an acronym for *generalized linear model*.
Generalized linear models (GLMs) are exactly what their name says, a *generalization* of linear regression.
GLMs include logistic regression as a special case.
To tell `glm` that we want to carry out a logistic regression, we need to specify `family = binomial(link = 'logit')`.
Otherwise the syntax is practically identical to that of `lm`.
We specify a *formula*, `y ~ x`, and indicate a dataframe in which R should look to find `y` and `x`:
```{r}
lreg <- glm(y ~ x, mydat, family = binomial(link = 'logit'))
summary(lreg)
```
Notice that the output of `summary` when applied to a `glm` object is a little different from what we've seen for `lm` objects.
But let's focus on what's the same.
We still obtain the estimates of each of the coefficients in our model, along with standard errors, test statistics, and p-values.
We can use this information to carry out statistical inference exactly as we do with linear regression: R has already done all the hard work for us by calculating the standard errors.

### Exercise \#4
Construct approximate 95\% confidence intervals for the parameters $\beta_0$ and $\beta_1$ based on the logistic regression output from above.
Do your confidence intervals include the true parameter values that we used to simulate the data?

## Solution to Exercise \#4
<!-- ANS_START -->
The confidence interval for the regression intercept is `r round(coef(lreg)[1], 2)` $\pm$ `r round(2 * sqrt(summary(lreg)$cov.scaled[1,1]), 2)` which includes the true value: $\beta_0=$ `r b0`. 
Similarly, the confidence interval for the regression slope is `r round(coef(lreg)[2], 2)` $\pm$  `r round(2 * sqrt(summary(lreg)$cov.scaled[2,2]), 2)` which includes the true value: $\beta_1 =$ `r b1`.
<!-- ANS_END -->

## Predicted Probabilities for Logistic Regression 
Many of the functions we used with `lm` also work with `glm`.
For example, to extract the coefficients from a generalized linear model, we can use the command `coef`:
```{r}
coef(lreg)
```
We can also use the function `predict` to calculated the predicted probability that $y = 1$ given particular values of the predictors $X_i$. 
There's just one slight wrinkle here: we need to make sure to specify `type = 'response'` to indicate to R that we want the predicted *probabilities*.
For example, we can calculate the predicted probability that $y_i = 1$ given that $X_i = 0$ as follows:
```{r}
predict(lreg, newdata = data.frame(x = 0), type = 'response')
```
Similarly, we can calculate the predicted probability that $y_i = 1$ given that $X_i$ equals the *sample mean* of $X$ as follows:
```{r}
predict(lreg, newdata = data.frame(x = mean(x)), type = 'response')
```
If we don't specify anything for `newdata`, then predict will give us the predicted probabilities for the *observed* values of $X$:
```{r}
phat <- predict(lreg, type = 'response')
head(phat)
```

### Exercise \#5
(a) Write an R function called `Lambda` that calculates the value of $e^z/(1 + e^z)$.
(b) Using your function from part (a) and the results of `lreg`, calculate the predicted probability that $y_i = 1$ when: (i) $X_i = 0$ and (ii) $X_i = \bar{X}$ *without using* `predict`. Check that your results match those calculated using `predict` above.

### Solution to Exercise \#5

<!-- ANS_START -->
```{r}
Lambda <- function(x) {
  1 / (1 + exp(-x))
}
bhat_0 <- coef(lreg)[1]
bhat_1 <- coef(lreg)[2]
Lambda(bhat_0)
Lambda(bhat_0 + bhat_1 * mean(x))
```
<!-- ANS_END -->

## Calculating Marginal Effects
As we discussed above, $\beta_j$ is *not* the partial derivative of $P(X)$ with respect to $X_j$.
But since we have a formula for this partial derivative, we can calculate it for any value of $X$.
In the following exercise, you will compare the exact calculation to the approximation given by the "divide by 4" rule.

### Exercise \#6
(a) Use the "divide by 4" rule to calculate the *maximum* possible effect of $X$ on the predicted probability that $y_i = 1$ using the results of `lreg`.
(b) Calculate the effect of $X$ on the predicted probability that $y_i= 1$ at $X_i = \bar{X}$.
(c) Compare your answers to (a) and (b)

### Solution to Exercise \#6
<!-- ANS_START -->
```{r}
# Divide by 4 rule
bhat_1 / 4

# Marginal effect at average x
linear_predictor <- bhat_0 + bhat_1 * mean(x)
bhat_1 * exp(linear_predictor) / (1 + exp(linear_predictor))^2
```
<!-- ANS_END -->

### Plotting a Logistic Regression
We can plot a logistic regression function using a method very similar to the one we used to plot a linear regression:
```{r}
library(ggplot2)
ggplot(mydat, aes(x, y)) +
  stat_smooth(method='glm', 
              method.args = list(family = "binomial"),
              formula = y ~ x) 
```

To add the datapoints, we just add `geom_point()`
```{r}
library(ggplot2)
ggplot(mydat, aes(x, y)) +
  stat_smooth(method='glm', method.args = list(family = "binomial"),
              formula = y ~ x) + 
  geom_point()
```

This doesn't look very nice!
That's because there are only *two* possible $y$-values meaning that the observations will overlap substantially.
A helpful way to distinguish them visually is to add a bit of random noise to the points so they no longer overlap.
This is called *jittering* and `ggplot2` will do it for us if we replace `geom_point()` with `geom_jitter()`
```{r}
library(ggplot2)
ggplot(mydat, aes(x, y)) +
  stat_smooth(method='glm', method.args = list(family = "binomial"),
              formula = y ~ x) + 
  geom_jitter()
```

That's a bit *too much* random noise in the $y$-dimension.
We can control the amount of jittering by specifying `width` and `height` arguments to `geom_jitter` as follows
```{r}
library(ggplot2)
ggplot(mydat, aes(x, y)) +
  stat_smooth(method='glm', method.args = list(family = "binomial"),
              formula = y ~ x) + 
  geom_jitter(width = 0.5, height = 0.1)
```

From this plot it is easy to tell that there are many more observations with $y = 1$ than $y = 0$, something that was not at all clear from the plot using `geom_point()`.


## Alternatives
