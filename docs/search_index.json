[["index.html", "Empirical Research Methods Preface About This Book Pre-requisites Why not Stata? Why not Matlab, Julia, or Python?", " Empirical Research Methods Francis J. DiTraglia 2022-02-20 Preface About This Book Supervising undergraduate, masters-level, and doctoral research students has shown me just how many of the skills that I take for granted in my day-to-day work were never taught in a course, but acquired through years of painful trial-and-error. You've probably heard that \"the only way to learn how to do research is by doing research.\" Indeed: classroom exercises are always somewhat artificial, and there is no substitute for getting your hands dirty with a problem that really matters to you. But trial-and-error is a slow and clumsy way to gain proficiency, and throwing students in at the deep end is neither a recipe for academic success nor for mental well-being. The goal of this book is to put some structure around the process through which students learn to do empirical work in economics, building a strong foundation for later self-directed reading and research. The book is divided into twenty-odd short chapters called lessons, each designed to take between one and two hours to complete. Broadly speaking, the material is a mix of applied econometrics, data science, and research skills. In keeping with the Swiss Army Knife logo, the idea is to teach you lots of little things that will come in handy later. While the topics covered below are something of a miscellany, there are strong connections between the lessons. For best results, complete them in order. A key theme that runs throughout the lessons is the importance of reproducible research using open-source tools. Reproducible research is about creating a clean and fully-documented path from raw data to final results, making errors less likely to occur and easier to find when they do. It also allows other researchers, or our future selves, to build on past work, expanding the sum total of knowledge. Of course I can only replicate your research if I can run your code, and this is why open-source software is so important. Fortunately there are many fantastic open-source programming languages to choose from. This book uses R, the lingua franca of statistics and an increasingly popular choice among economists. Pre-requisites This book does not assume advanced knowledge of programming, mathematics, or econometrics, but it does have some pre-requisites. My target audience is first-year graduate students and final-year undergraduates in economics. At Oxford, I use this book to teach a first-year master's level course on Empirical Research Methods that comes after students have completed 16 weeks of basic statistics and econometrics. I assume that you've taken an econometrics course that uses matrix notation and that you have basic familiarity with R programming. If you need to brush up on econometrics, I recommend Marno Verbeek's Guide to Modern Econometrics. I've linked to the third edition because it is particularly inexpensive used, buy any edition will do. At a more advanced level, Bruce Hansen's two volume series Econometrics is both excellent and free to download online. If you haven't used R before or feel the need for a bit of review, I suggest reading Hands-On Programming with R. It's free, short, and will get you up to speed quickly. Why not Stata? Given that much of the material discussed below falls under the broad category of \"applied microeconometrics\" you may wonder why I chose R rather than Stata. Indeed, Stata is easy-to-use, and makes it relatively painless to implement \"textbook\" microeconometric methods.1 So why don't I like Stata? Before beginning my polemic I should be absolutely clear that Stata users are not bad people: hate the sine, love the sinner. Here begins the sermon. First, Stata is expensive. The price for a Business single-user Stata license is $765 per year.2 If you want support for multicore computing, the price is even higher: an 8-core version of Stata costs $1,395 annually. There is no discount for Government or nonprofits, but as an Oxford faculty member, I can obtain an 8-core version of Stata for the low price of $595 per year, or around 9% of my annual research allowance. In contrast, the tools that we will learn in this book, mainly R and C++, are completely free. This is particularly important in the modern world of high-performance cluster computing. If you're considering running your code on a multicore machine on Amazon, Google, or Microsoft cloud servers, you don't want to pay a software license fee for every core that you use. Second, Stata is almost comically behind the times. Let's see what's new in Stata version 16, released in February 2020.3 At the top of the list is the LASSO, a wildly popular technique for high-dimensional regression. Rob Tibshirani developed this method in a seminal paper from 1996, so it only took 24 years for it to be incorporated into Stata.4 Fortunately, Tibshirani and his co-authors made it easy for Stata, by releasing open-source software to implement the LASSO and related methods in R over a decade ago.5 Next on the list of new Stata features is linear programming, a technique that came to prominence in the late 1940s.6 Stata 16 also has the ability to call \"any Python package\"--something you can do for free in R using reticulate or in Python itself for that matter--and \"truly reproducible reporting.\" Reproducible reporting is incredibly valuable, and it's something that we'll cover in detail below. It's also been available in R, completely free of charge, since at least 2002.7 I suppose we shouldn't expect too much of a statistical computing package that only added support for matrix programming in 2005, a full 20 years after Stata version 1.0.8 Third, Stata is a black box. Because the underlying source code is kept secret, there's no way for a Stata user to know for certain what's happening under the hood. A few years ago I tried to determine precisely what instrument set Stata was using in its implementation of a well-known dynamic panel estimator. The documentation was vague, so resorted to reverse-engineering the Stata results by trial-and-error in R. We never did get the results to match perfectly. In contrast, if you're not sure what a particular R function or package is doing, you can simply read the source code and find out. Fourth, and most importantly, Stata makes it hard to share with others. If I don't own a copy of Stata, I can't replicate your work. Even if I do own a copy of Stata, I still may not be able to so do: Stata's proprietary binary data formats are updated fairly regularly and do not maintain backwards compatibility. Datafiles created in Stata version 16, for example, cannot be opened in Stata 13. Indeed, depending on the number of variables included in your dataset, Stata 16 files cannot necessarily be opened even in Stata 15. Fortunately, as we'll see below, intrepid open-source programmers have developed free software to unlock data from Stata's proprietary and ever-changing binary formats. Why not Matlab, Julia, or Python? Unlike Stata, Matlab is a bona fide programming language and a fairly capable one at that. Nevertheless, my other critiques of Stata from above still apply: Matlab is extremely expensive, and it's not open source. In contrast, I have nothing bad to say about Python and Julia: they're great languages and you should consider learning one or both of them! A good resources aimed at economists is the quantecon.org: https://python.quantecon.org/ and https://julia.quantecon.org/. In the end I decided to choose one language and R struck me as the best choice for the moment. In five or ten years time, I could easily imagine re-writing this book in Julia, but as of this writing R has the advantage of maturity and a large, and generally extremely supportive community of users. Even if you ultimately decide that R isn't for you, fear not! After learning the material in this book, you'll find it fairly easy to transition to Python or Julia, should you so choose. Now let's get started! Arguably, Stata is too easy to learn precisely because of the incentives faced by a software developer with monopoly power: see Hal Varian's paper: Economic Incentives in Software Design. Monopolist may make software too easy to learn.↩︎ These figures were accurate as of March 2021. For the latest prices, see https://www.stata.com/order/dl/.↩︎ https://www.stata.com/new-in-stata/↩︎ Tibshirani (1996) - Regression Shrinkage and Selection via the Lasso↩︎ Friedman et al (2010) - Regularization Paths for Generalized Linear Models via Coordinate Descent↩︎ For a history of linear programming, see Dantzig (1983). To be completely fair, the linear programming algorithm implemented in Stata 16 was only developed in 1992, a lag of merely 28 years.↩︎ Reproducible reporting in R started with sweave. These days we have a fantastic successor package called knitr, which I cover below.↩︎ The \"Mata\" programming language was added in Stata 9: https://www.stata.com/stata9/. For a timeline of Stata versions, see https://www.stata.com/support/faqs/resources/history-of-stata/.↩︎ "],["rcrash.html", "Lesson 1 A Crash Course in R Programming 1.1 Installing R and RStudio 1.2 Working with R Scripts 1.3 The Absolute Basics 1.4 Part 3: Exercises", " Lesson 1 A Crash Course in R Programming This chapter will give you the bare minimum knowledge of R that you'll need to work through the rest of the book. While I won't assume any prior knowledge of R, I will assume that you've had some prior exposure to basic programming. Perhaps you know a little C or you've dabbled in Python. If you understand if and else, know the difference between for and while loops, and have written a simple function before, your background will be more than sufficient. If you lack this background, don't despair! You can still read and understand this book if you're willing to put in a bit of extra work in the early stages. If you've never done any programming before, I'd suggest reading Hands-On Programming with R alongside this chapter. It's freely available online and does an excellent job of introducing fundamental programming concepts. Advanced R R for Data Science R you ready?9 Are you certain? 1.1 Installing R and RStudio Carry out the following two steps in order Go to http://cran.r-project.org/ and install the version of R for your operating system. Go to http://rstudio.org/download/desktop and click the link listed under \"Recommended for Your System\". Follow the instructions to install RStudio. To make sure this worked, open the program RStudio and go to File &gt; New &gt; R Script. This will open a blank text document. In the document, type the text given in the box below and then click and drag to highlight both lines of code and click the button marked \"Run.\" If everything is working correctly, the console should display TRUE. x = 5 x == 5 Congratulations: you've just written your first R script! To save it, go to File &gt; Save As, and choose a name. NOTE: Always save your scripts as .R files so they'll open in RStudio by default. 1.2 Working with R Scripts Note that you can run one line of your script at a time by moving your cursor to that line and pressing CONTROL-ENTER or COMMAND-RETURN depending on whether you're running Mac OSX, Linux or Windows. Another helpful shortcut is CONTROL-A (COMMAND-A on Mac) which highlights all of the lines of code in the text editor. Explain how we proceed: save it somewhere where you can find it, how to work using the script, the console, help files, etc. 1.3 The Absolute Basics Here are some of the most fundamental things you can do with R. If you're having trouble installing R and or RStudio, fear not! A simple way to run snippets of R code in a browser is https://rdrr.io/snippets. You can also run a fully-fledged version of RStudio for free here https://rstudio.cloud/plans/free until you get your local installation working correctly. (Note that you are limited to 15 free hours per month.) 1.3.1 Arithmetic R has support for all of the usual mathematical operations: + and - perform addition and subtraction, while * and / perform multiplication and division. Parentheses can be used to change the order of operations: 3 * 4 + 3 / 2 ## [1] 13.5 3 * (4 + 3) / 2 ## [1] 10.5 1.3.2 Exponents, Logarithms, and Trigonometry ?log ffalse{-91-80-121-116-104-97-103-111-114-101-97-110-32-84-104-101-111-114-101-109-93-} Exercise 1.1 \\iffalse (Pythagorean Theorem) Use R to compute the length of the hypotenuse of a right triangle whose sides have lengths 4 and 7. Solution sqrt(4^2 + 7^2) ## [1] 8.062258 #add numbers 1 + 1 ## [1] 2 #subtract them 8 - 4 ## [1] 4 #divide 13/2 ## [1] 6.5 #multiply 4*pi ## [1] 12.56637 #exponentiate 2^10 ## [1] 1024 1.3.3 Logical Comparison 3 &lt; 4 ## [1] TRUE 3 &gt; 4 ## [1] FALSE #contrast with 3 = 4; see section about variables below 3 == 4 ## [1] FALSE #!= means &quot;not equal to&quot; 3 != 4 ## [1] TRUE 4 &gt;= 5 ## [1] FALSE 4 &lt;= 5 ## [1] TRUE 2 + 2 == 5 ## [1] FALSE 10 - 6 == 4 ## [1] TRUE 1.3.4 Strings (text) Numbers are bread and butter for computers, but text is what will facilitate understanding for us mere mortals. &#39;Econometrics is awesome&#39; ## [1] &quot;Econometrics is awesome&quot; #R delimits strings with EITHER double or single quotes. # There is only a very minimal difference &quot;Econometrics is still awesome&quot; ## [1] &quot;Econometrics is still awesome&quot; 1.3.5 Variables Just like in algebra, variables are a great form of shorthand. Instead of writing 3.1415926... all the time, we can just write pi. Assignment to a variable happens from right to left -- the value on the right side gets assigned to the name on the left side. You can use nearly anything as a variable name in R. The only rules are: . and _ are OK, but no other symbols. Your variable name must not start with a number or _ (2squared and _one are illegal). [A note for those of you who have programming experience: while R supports object-oriented programming, periods . do not have a special meaning in the language. For historical reasons, R programmers often use periods in place of underscores in variable names, but either works. Just be consistent to keep your code readable.] x = 42 x / 2 ## [1] 21 #if we assign something else to x, # the old value is deleted x = &quot;Melody to Funkytown!&quot; x ## [1] &quot;Melody to Funkytown!&quot; x = 5 x == 5 ## [1] TRUE foo = 3 bar = 5 foo.bar = foo + bar foo.bar ## [1] 8 foo.bar2 = 2 * foo.bar foo.bar2 ## [1] 16 foo_bar = foo - bar foo_bar ## [1] -2 Note: In programmer speak, = here is an \"assignment operator\" -- it's the thing used to assign values to a variable name. R also has a second assignment operator that you're bound to see sooner or later, &lt;-. So x &lt;- 42 and x = 42 are identical, and both accomplish the task of assigning the value of 42 to the name x. We'll try to stick with using = since it's easier to type and in some ways more intuitive. See this wonderful post for some more history and a very subtle difference between the two operators that you needn't concern yourself with for now. 1.3.6 Vectors &amp; Types In R, a vector is just a (ordered) set of related things. You should basically think of it like a column in Excel. x = c(4, 7, 9) x ## [1] 4 7 9 y = c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) y ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 4, 7, and 9 are \"related\" because they're all numbers; a, b and c are all letters. Having variables is becoming more convenient -- instead of having to write c(4, 7, 9) all the time, we can just write x. What happens when we try and combine things that aren't so obviously related? x = c(1, TRUE, &quot;three&quot;) x ## [1] &quot;1&quot; &quot;TRUE&quot; &quot;three&quot; Note the quotation marks. R has converted 1 and TRUE into text representations. That's because 1 and TRUE are different _type_s than \"three\". There are four basic types of variables your likely to encounter in this class, listed here in heirarchical order: logical: TRUE or FALSE integer: 0L, -1L, 1L, etc. A (real) number without a decimal part. Technical note: they take up less space in the computer than numbers with decimals. numeric: pi, 0.34, 1.4043, etc. A real number. character: \"some words\", \"more words\", etc. Vectors are converted to the highest number on this list present -- x above has \"three\" so the whole vector becomes a character. 1.3.7 Vector Arithmetic and Functions Vectors make it easy to do many computations all at once -- adding one to a list of numbers, dividing all of them by 3, etc. And as long as two vectors are the same length, we can combine them in natural ways: x = c(1, 2, 3) x + 4 ## [1] 5 6 7 x/3 ## [1] 0.3333333 0.6666667 1.0000000 -x ## [1] -1 -2 -3 x^3 ## [1] 1 8 27 y = c(3, 2, 1) x - y ## [1] -2 0 2 x * y ## [1] 3 4 3 x/y ## [1] 0.3333333 1.0000000 3.0000000 x &gt; 2 ## [1] FALSE FALSE TRUE x &gt;= 2 ## [1] FALSE TRUE TRUE Just like in math, a function is a way of mapping input to output, and just like in most math classes, you can spot functions since they use parentheses: (). We've already seen the _c_oncatenate function c used (for example) to create vectors. We can also apply any number of ubiquitous functions to our vector input. Just a small taste: x = c(1, 2, 3) #sum: add up the elements of a vector sum(x) ## [1] 6 #Just like you can use the command sum to add up the # elements of a numeric vector, you can use # prod to take their product: prod(x) ## [1] 6 sqrt(x) ## [1] 1.000000 1.414214 1.732051 y = c(-1, 2, 4) #abs: absolute value abs(y) ## [1] 1 2 4 #exp: exponential. exp(x) is e^x exp(y) ## [1] 0.3678794 7.3890561 54.5981500 #log: _natural_ logarithm (base e) log(x) ## [1] 0.0000000 0.6931472 1.0986123 #Note that these functions interpret their input # as *radians* rather than degrees. sin(x) + cos(y) ## [1] 1.3817733 0.4931506 -0.5125236 max(y) ## [1] 4 min(y) ## [1] -1 range(y) ## [1] -1 4 mean(x) ## [1] 2 median(x) ## [1] 2 Another thing that we will do all the time is use regularly-spaced sequences of numbers. These are created in R with : or seq: x = 1:10 x ## [1] 1 2 3 4 5 6 7 8 9 10 y = 10:1 y ## [1] 10 9 8 7 6 5 4 3 2 1 #some times the gap is not 1 z = seq(0, 1, by = .02) z ## [1] 0.00 0.02 0.04 0.06 0.08 0.10 0.12 0.14 0.16 0.18 0.20 0.22 0.24 0.26 0.28 ## [16] 0.30 0.32 0.34 0.36 0.38 0.40 0.42 0.44 0.46 0.48 0.50 0.52 0.54 0.56 0.58 ## [31] 0.60 0.62 0.64 0.66 0.68 0.70 0.72 0.74 0.76 0.78 0.80 0.82 0.84 0.86 0.88 ## [46] 0.90 0.92 0.94 0.96 0.98 1.00 #other times we care less about the gap and more # more about how many points we get out w = seq(0, 1, length.out = 20) In addition to math/arithmetic functions, there is a litany of basic programming functions that you're likely to use all of the time: x = 99:32 #length: how many elements (items) are there in x? length(x) ## [1] 68 y = c(&quot;hey you!&quot;, &quot;out there in the cold&quot;) #what TYPE of variable does R think this is? class(y) ## [1] &quot;character&quot; #rep: repeat/reproduce rep(y, 4) ## [1] &quot;hey you!&quot; &quot;out there in the cold&quot; &quot;hey you!&quot; ## [4] &quot;out there in the cold&quot; &quot;hey you!&quot; &quot;out there in the cold&quot; ## [7] &quot;hey you!&quot; &quot;out there in the cold&quot; #head/tail: display only the beginning/end # of an object -- very useful for very # large objects x = 1:100000 head(x) ## [1] 1 2 3 4 5 6 tail(x) ## [1] 99995 99996 99997 99998 99999 100000 1.3.8 Subsetting Vectors: [ Often we want to examine only part of a vector, most commonly the part of a vector that satisfies some condition, but also looking at the first or last few elements. To do this we extract or subset those elements by using [: x = c(5, 4, 1) x[1] ## [1] 5 x[3] ## [1] 1 x[1:2] ## [1] 5 4 x[2:3] ## [1] 4 1 In the syntax x[something], note that something is itself a vector! So the above is all short-hand for the more complicated types of subsets: x = 20:30 x ## [1] 20 21 22 23 24 25 26 27 28 29 30 x[c(1, 3, 5)] ## [1] 20 22 24 x[c(5, 9)] ## [1] 24 28 x[seq(1, 10, by = 2)] ## [1] 20 22 24 26 28 Besides being an integer, something can be a logical vector of the same length as the vector itself: x = c(5, 6, 7) x[c(TRUE, TRUE, FALSE)] ## [1] 5 6 x[c(FALSE, TRUE, FALSE)] ## [1] 6 x[c(FALSE, FALSE, TRUE)] ## [1] 7 Most commonly we'll do something that's identical to the above but reads more naturally: x = c(-1, 0, 1) x &gt; 0 ## [1] FALSE FALSE TRUE x[x &gt; 0] ## [1] 1 x[x &lt;= 0] ## [1] -1 0 We can also replace parts of a vector by subsetting: x = c(-1, 5, 10) x[3] = 4 x ## [1] -1 5 4 x[x &lt; 0] = 0 1.3.9 Named Vectors It's also often useful to name our vectors to help organize the information. Suppose we were keeping track of the ages of the Trumps: trump_ages = c(70, 46, 38, 34, 32, 22, 9) This is nice, but much more useful if we keep track of who each element represents: trump_ages = c(Donald = 70, Melania = 46, Donald_Jr = 38, Ivanka = 34, Eric = 32, Tiffany = 22, Barron = 9) trump_ages ## Donald Melania Donald_Jr Ivanka Eric Tiffany Barron ## 70 46 38 34 32 22 9 We can also use the names function to assign names; this is sometimes easier, e.g., if the names have spaces: names(trump_ages) = c(&quot;Donald&quot;, &quot;Melania&quot;, &quot;Donald, Jr.&quot;, &quot;Ivanka&quot;, &quot;Eric&quot;, &quot;Tiffany&quot;, &quot;Barron&quot;) trump_ages ## Donald Melania Donald, Jr. Ivanka Eric Tiffany ## 70 46 38 34 32 22 ## Barron ## 9 This also makes code for subsetting much easier to read, since we can subset by the names: trump_ages[&quot;Donald&quot;] ## Donald ## 70 trump_ages[c(&quot;Donald&quot;, &quot;Barron&quot;)] ## Donald Barron ## 70 9 1.3.10 Getting Help: Documentation If you're unsure of how something works in R -- what the arguments are to a function, how it works, etc. -- your first step is to check the documentation: ?sum ?cos ?&quot;=&quot; 1.3.11 Lists We saw above that R doesn't like vectors to have different types: c(TRUE, 1, \"Frank\") becomes c(\"TRUE\", \"1\", \"Frank\"). But storing objects with different types is absolutely fundamental to data analysis. R has a different type of object besides a vector used to store data of different types side-by-side: a list: x = list(TRUE, 1, &quot;Frank&quot;) x ## [[1]] ## [1] TRUE ## ## [[2]] ## [1] 1 ## ## [[3]] ## [1] &quot;Frank&quot; Note how different the output looks, as compared to using c!! The quotation marks are gone except for the last component. You can ignore the mess of [[ and [ for now, but as an intimation, consider some more complicated lists: x = list(c(1, 2), c(&quot;a&quot;, &quot;b&quot;), c(TRUE, FALSE), c(5L, 6L)) x ## [[1]] ## [1] 1 2 ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; ## ## [[3]] ## [1] TRUE FALSE ## ## [[4]] ## [1] 5 6 y = list(list(1, 2, 3), list(4:5), 6) y ## [[1]] ## [[1]][[1]] ## [1] 1 ## ## [[1]][[2]] ## [1] 2 ## ## [[1]][[3]] ## [1] 3 ## ## ## [[2]] ## [[2]][[1]] ## [1] 4 5 ## ## ## [[3]] ## [1] 6 x is a list which has 4 components, each of which is a vector with 2 components. This gives the first hint at how R treats a dataset with many variables of different types – at core, R stores a data set in a list! y is a nested list – it’s a list that has lists for some of its components. This is very useful for more advanced operations, but probably won’t come up for quite some time, so don’t worry if you haven’t wrapped your head around this yet. 1.3.12 Packages One of the things that makes R truly exceptional is its vast library of user-contributed packages. R comes pre-loaded with a boat-load of the most common functions / methods of analysis. But in no way is this congenital library complete. Complementing this core of the most common operations are external packages, which are basically sets of functions designed to accomplish specific tasks. Best of all, unlike some super-expensive programming languages, all of the thousands of packages available to R users (most importantly through CRAN, the Comprehensive R Archive Network) are completely free of charge. The two most important things to know about packages for now is where to find them, how to install them, and how to load them. We'll work extensively with the data.table package, which was built for working with huge data sets. 1.3.12.1 Where to find packages Long story short: Google. Got a particular statistical technique in mind? The best R package for this is almost always the top Google result if asked correctly. 1.3.12.2 How to install packages Just use install.packages! install.packages(&quot;data.table&quot;) This will download the code from the package to your computer to a place that R understands. We do not yet have access to the functions in the package. We have to load it first. 1.3.12.3 How to load packages Just add it to your library! library(data.table) Et voila! You'll now have access to all of the awesome functions in the data.table package. You can also Google \"tutorial data.table\" (or in general \"tutorial [package name]\") and you're very likely to find a trove of sites trying to help you learn the package. 1.3.13 data.tables Data sets are the lifeblood of a data lover! As mentioned above, data sets in R basically lists where every element has the same length. In basic R, this is done with a data.frame, but it'll be easier for a beginner to understand the syntax of a data.table, so you can forget about data.frames for now. We can build a data.table from scratch with the data.table command. This command lets you build up a data.table from several vectors of the same length: foo = 1:5 bar = 2 * foo foo.bar = data.table(foo, bar) foo.bar ## foo bar ## 1: 1 2 ## 2: 2 4 ## 3: 3 6 ## 4: 4 8 ## 5: 5 10 In the preceding example I built a data.table with only two columns, but you can add as many as you like. Just separate them by commas: y = -4:0 data.table(foo, bar, y) ## foo bar y ## 1: 1 2 -4 ## 2: 2 4 -3 ## 3: 3 6 -2 ## 4: 4 8 -1 ## 5: 5 10 0 1.3.14 Subsetting data When you're working with data, you'll often want to look at subsets that satisfy a particular condition. First we'll set up a simple data.table: location = c(&quot;New York&quot;, &quot;Chicago&quot;, &quot;Boston&quot;, &quot;Boston&quot;, &quot;New York&quot;) salary = c(70000, 80000, 60000, 50000, 45000) title = c(&quot;Office Manager&quot;, &quot;Research Assistant&quot;, &quot;Analyst&quot;, &quot;Office Manager&quot;, &quot;Analyst&quot;) hours = c(50, 56, 65, 40, 50) jobsearch = data.table(location, salary, title, hours) jobsearch ## location salary title hours ## 1: New York 70000 Office Manager 50 ## 2: Chicago 80000 Research Assistant 56 ## 3: Boston 60000 Analyst 65 ## 4: Boston 50000 Office Manager 40 ## 5: New York 45000 Analyst 50 Now, suppose you wanted to see only the jobs in New York. You could select them as follows: jobsearch[location == &#39;New York&#39;] ## location salary title hours ## 1: New York 70000 Office Manager 50 ## 2: New York 45000 Analyst 50 Notice the use of the double equal sign. This command is testing a logical condition. If you use a single equals sign, this won't work since = is what is used to name the arguments to a function in R. The preceding command looks at the data.table jobsearch and then the column location and checks which entries satisfy the condition that the location is \"New York\". Finally, the function returns only these rows of the data.table. Now suppose you wanted to extract only those jobs that pay more than $50,000. The command for this is as follows: jobsearch[salary &gt; 50000] ## location salary title hours ## 1: New York 70000 Office Manager 50 ## 2: Chicago 80000 Research Assistant 56 ## 3: Boston 60000 Analyst 65 Finally, suppose the most you're willing to work per week is 50 hours. Here are the jobs you should consider: jobsearch[hours &lt;= 50] ## location salary title hours ## 1: New York 70000 Office Manager 50 ## 2: Boston 50000 Office Manager 40 ## 3: New York 45000 Analyst 50 1.3.15 Loading External Data &amp; Data Summary The vast majority of the time, you won't be using data that you type in by hand -- you'll be importing data from external sources. One of the most common ways to find such data is in comma-separated format -- such files are structured such that each row represents a row of data, and columns are separated by a comma (actually, any separating character is possible), e.g., like this: name,age,company Mike,24,BCG Rodrigo,25,Uber Frank,28,FMC Ethan,22,AirBnB It's very easy to read files like this into R very quickly using fread. The weather site Weather Underground offers lots of historical data in such tabular format. E.g., the data on this page about the weather recorded at Philadelphia International Airport is available as a .csv online here. We can read this into R like so: weather = fread(&#39;http://michaelchirico.github.io/philly_weather_data.csv&#39;) weather ## EST Max TemperatureF Mean TemperatureF Min TemperatureF ## 1: 2017-01-01 51 42 34 ## 2: 2017-01-02 43 38 32 ## 3: 2017-01-03 48 44 41 ## 4: 2017-01-04 54 45 35 ## 5: 2017-01-05 34 31 28 ## 6: 2017-01-06 32 29 26 ## 7: 2017-01-07 24 22 19 ## 8: 2017-01-08 24 20 15 ## 9: 2017-01-09 23 18 12 ## 10: 2017-01-10 42 28 14 ## 11: 2017-01-11 54 46 37 ## 12: 2017-01-12 66 56 45 ## 13: 2017-01-13 61 48 35 ## 14: 2017-01-14 36 33 30 ## Max Dew PointF MeanDew PointF Min DewpointF Max Humidity Mean Humidity ## 1: 29 26 24 75 48 ## 2: 41 37 25 96 88 ## 3: 46 42 39 97 93 ## 4: 46 36 10 96 74 ## 5: 27 17 8 92 58 ## 6: 28 21 9 93 70 ## 7: 18 13 4 89 68 ## 8: 7 3 -1 57 46 ## 9: 9 6 4 73 56 ## 10: 32 18 9 84 62 ## 11: 46 40 33 93 80 ## 12: 52 50 46 90 74 ## 13: 50 30 14 89 63 ## 14: 23 17 11 61 50 ## Min Humidity Max Sea Level PressureIn Mean Sea Level PressureIn ## 1: 30 30.42 30.19 ## 2: 66 30.45 30.35 ## 3: 89 30.18 29.79 ## 4: 14 29.83 29.58 ## 5: 23 30.05 29.98 ## 6: 31 30.31 30.05 ## 7: 33 30.33 30.24 ## 8: 29 30.69 30.44 ## 9: 36 30.81 30.72 ## 10: 38 30.66 30.48 ## 11: 59 30.37 30.26 ## 12: 50 30.19 30.11 ## 13: 36 30.71 30.45 ## 14: 30 30.71 30.62 ## Min Sea Level PressureIn Max VisibilityMiles Mean VisibilityMiles ## 1: 29.94 10 10 ## 2: 30.19 10 6 ## 3: 29.53 10 4 ## 4: 29.48 10 6 ## 5: 29.85 10 8 ## 6: 29.92 10 7 ## 7: 30.18 10 5 ## 8: 30.25 10 10 ## 9: 30.67 10 10 ## 10: 30.20 10 10 ## 11: 30.19 10 8 ## 12: 30.02 10 10 ## 13: 30.14 10 10 ## 14: 30.49 10 10 ## Min VisibilityMiles Max Wind SpeedMPH Mean Wind SpeedMPH Max Gust SpeedMPH ## 1: 10 18 12 25 ## 2: 2 15 8 25 ## 3: 2 15 11 28 ## 4: 2 24 12 34 ## 5: 1 21 11 28 ## 6: 0 13 5 17 ## 7: 0 17 13 25 ## 8: 10 24 15 31 ## 9: 10 10 7 NA ## 10: 10 17 7 29 ## 11: 5 22 12 30 ## 12: 6 21 15 29 ## 13: 10 24 13 30 ## 14: 6 10 5 NA ## PrecipitationIn CloudCover Events WindDirDegrees ## 1: 0.00 4 274 ## 2: 0.16 8 Rain 52 ## 3: 0.20 8 Rain 31 ## 4: 0.01 6 Rain 250 ## 5: 0.03 7 Snow 253 ## 6: 0.04 8 Snow 336 ## 7: 0.08 7 Fog-Snow 1 ## 8: 0.00 1 294 ## 9: 0.00 4 228 ## 10: 0.01 7 175 ## 11: 0.24 7 Rain 212 ## 12: 0.03 7 Rain 218 ## 13: T 6 326 ## 14: 0.00 8 Snow 67 summary(weather) ## EST Max TemperatureF Mean TemperatureF Min TemperatureF ## Min. :2017-01-01 Min. :23.00 Min. :18.00 Min. :12.00 ## 1st Qu.:2017-01-04 1st Qu.:32.50 1st Qu.:28.25 1st Qu.:20.75 ## Median :2017-01-07 Median :42.50 Median :35.50 Median :31.00 ## Mean :2017-01-07 Mean :42.29 Mean :35.71 Mean :28.79 ## 3rd Qu.:2017-01-10 3rd Qu.:53.25 3rd Qu.:44.75 3rd Qu.:35.00 ## Max. :2017-01-14 Max. :66.00 Max. :56.00 Max. :45.00 ## ## Max Dew PointF MeanDew PointF Min DewpointF Max Humidity ## Min. : 7.00 Min. : 3.00 Min. :-1.00 Min. :57.00 ## 1st Qu.:24.00 1st Qu.:17.00 1st Qu.: 8.25 1st Qu.:77.25 ## Median :30.50 Median :23.50 Median :10.50 Median :89.50 ## Mean :32.43 Mean :25.43 Mean :16.79 Mean :84.64 ## 3rd Qu.:46.00 3rd Qu.:36.75 3rd Qu.:24.75 3rd Qu.:93.00 ## Max. :52.00 Max. :50.00 Max. :46.00 Max. :97.00 ## ## Mean Humidity Min Humidity Max Sea Level PressureIn ## Min. :46.00 Min. :14.00 Min. :29.83 ## 1st Qu.:56.50 1st Qu.:30.00 1st Qu.:30.22 ## Median :65.50 Median :34.50 Median :30.39 ## Mean :66.43 Mean :40.29 Mean :30.41 ## 3rd Qu.:74.00 3rd Qu.:47.00 3rd Qu.:30.68 ## Max. :93.00 Max. :89.00 Max. :30.81 ## ## Mean Sea Level PressureIn Min Sea Level PressureIn Max VisibilityMiles ## Min. :29.58 Min. :29.48 Min. :10 ## 1st Qu.:30.07 1st Qu.:29.93 1st Qu.:10 ## Median :30.25 Median :30.16 Median :10 ## Mean :30.23 Mean :30.07 Mean :10 ## 3rd Qu.:30.45 3rd Qu.:30.20 3rd Qu.:10 ## Max. :30.72 Max. :30.67 Max. :10 ## ## Mean VisibilityMiles Min VisibilityMiles Max Wind SpeedMPH Mean Wind SpeedMPH ## Min. : 4.000 Min. : 0.000 Min. :10.00 Min. : 5.00 ## 1st Qu.: 6.250 1st Qu.: 2.000 1st Qu.:15.00 1st Qu.: 7.25 ## Median : 9.000 Median : 5.500 Median :17.50 Median :11.50 ## Mean : 8.143 Mean : 5.286 Mean :17.93 Mean :10.43 ## 3rd Qu.:10.000 3rd Qu.:10.000 3rd Qu.:21.75 3rd Qu.:12.75 ## Max. :10.000 Max. :10.000 Max. :24.00 Max. :15.00 ## ## Max Gust SpeedMPH PrecipitationIn CloudCover Events ## Min. :17.00 Length:14 Min. :1.000 Length:14 ## 1st Qu.:25.00 Class :character 1st Qu.:6.000 Class :character ## Median :28.50 Mode :character Median :7.000 Mode :character ## Mean :27.58 Mean :6.286 ## 3rd Qu.:30.00 3rd Qu.:7.750 ## Max. :34.00 Max. :8.000 ## NA&#39;s :2 ## WindDirDegrees ## Min. : 1.0 ## 1st Qu.: 94.0 ## Median :223.0 ## Mean :194.1 ## 3rd Qu.:268.8 ## Max. :336.0 ## names(weather) ## [1] &quot;EST&quot; &quot;Max TemperatureF&quot; ## [3] &quot;Mean TemperatureF&quot; &quot;Min TemperatureF&quot; ## [5] &quot;Max Dew PointF&quot; &quot;MeanDew PointF&quot; ## [7] &quot;Min DewpointF&quot; &quot;Max Humidity&quot; ## [9] &quot;Mean Humidity&quot; &quot;Min Humidity&quot; ## [11] &quot;Max Sea Level PressureIn&quot; &quot;Mean Sea Level PressureIn&quot; ## [13] &quot;Min Sea Level PressureIn&quot; &quot;Max VisibilityMiles&quot; ## [15] &quot;Mean VisibilityMiles&quot; &quot;Min VisibilityMiles&quot; ## [17] &quot;Max Wind SpeedMPH&quot; &quot;Mean Wind SpeedMPH&quot; ## [19] &quot;Max Gust SpeedMPH&quot; &quot;PrecipitationIn&quot; ## [21] &quot;CloudCover&quot; &quot;Events&quot; ## [23] &quot;WindDirDegrees&quot; NB: More typically, instead of a URL, you'll give fread the path to where a .csv file is stored on your computer. 1.3.16 More on data.table Access One of the most fundamental R skills you'll need to learn is how to access parts of a data.table or vector. This can be a little confusing at first since there are usually several different ways to accomplish the same thing. This section is intended to add more clarity to some of the material on data.tables from above. The best way to learn this is to play around with different commands and see what happens. There are some exercises at the end of the tutorial to do just that. If you don't get the result you were expecting, try to think about why. First I'll build a simple data.table from the following vectors: person = c(&quot;Linus&quot;, &quot;Snoopy&quot;, &quot;Lucy&quot;, &quot;Woodstock&quot;) age = c(5, 8, 6, 2) weight = c(40, 25, 50, 1) my.data.table = data.table(person, age, weight) my.data.table ## person age weight ## 1: Linus 5 40 ## 2: Snoopy 8 25 ## 3: Lucy 6 50 ## 4: Woodstock 2 1 1.3.16.1 Fact #1: You can use the same principles to select subsets of vectors and data.tables by position The only real difference here is that vectors are one-dimensional age[1:2] ## [1] 5 8 age[c(1,3)] ## [1] 5 6 whereas data.tables are two-dimensional; the first dimension is rows: my.data.table[1:2] ## person age weight ## 1: Linus 5 40 ## 2: Snoopy 8 25 my.data.table[c(1, 3)] ## person age weight ## 1: Linus 5 40 ## 2: Lucy 6 50 The second dimension is columns; we can specify rows and columns by giving two numbers inside []: #what is the first row of the third column? my.data.table[1, 3] ## weight ## 1: 40 #what are the first three rows of the third column? my.data.table[1:3, 3] ## weight ## 1: 40 ## 2: 25 ## 3: 50 If you leave the part before the comma blank, you get all the rows: my.data.table[ , 2:3] ## age weight ## 1: 5 40 ## 2: 8 25 ## 3: 6 50 ## 4: 2 1 If you leave the part after the comma blank (or don't include it at all), you get all the columns: my.data.table[c(1,3), ] ## person age weight ## 1: Linus 5 40 ## 2: Lucy 6 50 my.data.table[c(2,4)] ## person age weight ## 1: Snoopy 8 25 ## 2: Woodstock 2 1 1.3.16.2 Fact #2: There are three ways to access the columns of a data.table by name. The first way is to use [[\"COLUMN NAME GOES HERE\"]] my.data.table[[&quot;weight&quot;]] ## [1] 40 25 50 1 The second is to use $, which is often faster to type since it doesn't require the use of quotation marks: my.data.table$weight ## [1] 40 25 50 1 Both of the preceding methods are limited in that they only allow us to reference a single column. We can reference multiple columns as follows: my.data.table[ , c(&quot;person&quot;, &quot;weight&quot;)] ## person weight ## 1: Linus 40 ## 2: Snoopy 25 ## 3: Lucy 50 ## 4: Woodstock 1 Since we left the part before the comma blank, this gave us all the rows. We could get the same thing by accessing these columns by position (though this is generally not recommended) my.data.table[ , 2] ## age ## 1: 5 ## 2: 8 ## 3: 6 ## 4: 2 my.data.table[ , c(1,2)] ## person age ## 1: Linus 5 ## 2: Snoopy 8 ## 3: Lucy 6 ## 4: Woodstock 2 my.data.table[ , 1:2] ## person age ## 1: Linus 5 ## 2: Snoopy 8 ## 3: Lucy 6 ## 4: Woodstock 2 In some cases it's easier to access columns of a data.table by name and in others it's easier to access them by position. 1.4 Part 3: Exercises If you can't get R and RStudio to work on your computer, you can do the exercises on the R Fiddle website http://www.r-fiddle.org/#/ Calculate how many minutes there are in a January 60 * 24 * 7 * 31 ## [1] 312480 Add up the numbers 3 1 4 1 5 9 2 6 without using any plus signs sum(c(3,1,4,1,5,9,2,6)) ## [1] 31 Load the help file for the function summary, and use summary on an object. ?summary summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## Suppose I ran the following R commands in order. What result would I get after the fourth command? Do not use R to answer this: think it through and then check your answer. x = 5 y = 7 z = x + y z + 3 == 15 x = 5 y = 7 z = x + y z + 3 == 15 ## [1] TRUE How can I get R to print out \"Go Penn!\" thirty times without repeatedly typing this by hand? rep(&quot;Go Penn&quot;, times = 30) ## [1] &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; ## [8] &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; ## [15] &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; ## [22] &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; &quot;Go Penn&quot; ## [29] &quot;Go Penn&quot; &quot;Go Penn&quot; Create a vector called x containing the sequence -1, -0.9, ... 0, 0.1, ..., 0.9, 1 and then display the result x = seq(-1, 1, 0.1) x ## [1] -1.0 -0.9 -0.8 -0.7 -0.6 -0.5 -0.4 -0.3 -0.2 -0.1 0.0 0.1 0.2 0.3 0.4 ## [16] 0.5 0.6 0.7 0.8 0.9 1.0 Create two vectors: wizards and ranking. The vector wizards should contain the following names: Harry, Ron, Fred, George, Sirius. The vector ranking should contain the following numbers: 4, 2, 5, 1, 3 in it. Make sure to put these in order. #Remember that the elements of character vectors need to be enclosed in quotation marks. Either single or double quotes will work. wizards = c(&quot;Harry&quot;, &quot;Ron&quot;, &quot;Fred&quot;, &quot;George&quot;, &quot;Sirius&quot;) ranking = c(4, 2, 5, 1, 3) Extract the second element of the vector wizards. wizards[2] ## [1] &quot;Ron&quot; Replace the names Fred, George and Sirius in the vector wizards with Hermione, Ginny and Malfoy, respectively. #There are several different ways to do this. Here are two possibilities. wizards[c(3, 4, 5)] = c(&quot;Hermione&quot;, &quot;Ginny&quot;, &quot;Malfoy&quot;) wizards[3:5] = c(&quot;Hermione&quot;, &quot;Ginny&quot;, &quot;Malfoy&quot;) Someone who hasn't read Harry Potter needs labels to determine who these characters are. Assign names to the elements of the vector wizards: Lead, Friend, Friend, Wife, Rival. Display the result. names(wizards) = c(&quot;Lead&quot;, &quot;Friend&quot;, &quot;Friend&quot;, &quot;Wife&quot;, &quot;Rival&quot;) wizards ## Lead Friend Friend Wife Rival ## &quot;Harry&quot; &quot;Ron&quot; &quot;Hermione&quot; &quot;Ginny&quot; &quot;Malfoy&quot; An avid reader of Harry Potter argues that Malfoy is not Harry's rival by the end of the series. Change Rival to Ex-Rival. names(wizards)[5] = &quot;Ex-Rival&quot; names(wizards) ## [1] &quot;Lead&quot; &quot;Friend&quot; &quot;Friend&quot; &quot;Wife&quot; &quot;Ex-Rival&quot; In 2009 Steve's income was $50,000 and his total expenses were $35,000. In 2010 his income was $52,000 and his expenses were $34,000. In 2011, his income was $52,500 and his expenses were $38,000. Finally, in 2012 Steve's earnings were $48,000 and his expenses were $40,000. Create three vectors to store this information in parallel: years, income and expenses. years = c(2009, 2010, 2011, 2012) income = c(50000, 52000, 52500, 48000) expenses = c(35000, 34000, 38000, 40000) Following on from the previous question, calculate Steve's annual savings and store this in a vector called savings. savings = income - expenses Assuming zero interest on bank deposits (roughly accurate at the moment), calculate the total amount that Steve has saved over all the years for which we have data. sum(savings) ## [1] 55500 Create a vector called z that lists the numbers from 12 to 23 in descending order. z = 23:12 z ## [1] 23 22 21 20 19 18 17 16 15 14 13 12 Replace the number 13 with the number 7 in z. z[z == 13] = 7 z ## [1] 23 22 21 20 19 18 17 16 15 14 7 12 Twenty-six students took the midterm. Here are their scores: 18, 95, 76, 90, 84, 83, 80, 79, 63, 76, 55, 78, 90, 81, 88, 89, 92, 73, 83, 72, 85, 66, 77, 82, 99, 87. Assign these values to a vector called scores. scores = c(18, 95, 76, 90, 84, 83, 80, 79, 63, 76, 55, 78, 90, 81, 88, 89, 92, 73, 83, 72, 85, 66, 77, 82, 99, 87) Calculate the mean, median, and range of the scores. mean(scores) ## [1] 78.5 median(scores) ## [1] 81.5 range(scores) ## [1] 18 99 Create three vectors. First store the numeric values 21, 26, 51, 22, 160, 160, 160 in a vector called age. Next, store the names Achilles, Hector, Priam, Paris, Apollo, Athena, Aphrodite in a character vector called person. Finally store the words Aggressive, Loyal, Regal, Cowardly, Proud, Wise, Conniving in a vector called description age = c(21, 26, 51, 22, 160, 160, 160) person = c(&quot;Achilles&quot;, &quot;Hector&quot;, &quot;Priam&quot;, &quot;Paris&quot;, &quot;Apollo&quot;, &quot;Athena&quot;, &quot;Aphrodite&quot;) description = c(&quot;Aggressive&quot;, &quot;Loyal&quot;, &quot;Regal&quot;, &quot;Cowardly&quot;, &quot;Proud&quot;, &quot;Wise&quot;, &quot;Conniving&quot;) Create a data.table called trojan.war whose columns contain the vectors from the previous question. trojan.war = data.table(person, age, description) Suppose you wanted to display only the column of trojan.war that contains each person's description. What command would you use? #There are many different ways to do this: trojan.war[, 3] ## description ## 1: Aggressive ## 2: Loyal ## 3: Regal ## 4: Cowardly ## 5: Proud ## 6: Wise ## 7: Conniving trojan.war$description ## [1] &quot;Aggressive&quot; &quot;Loyal&quot; &quot;Regal&quot; &quot;Cowardly&quot; &quot;Proud&quot; ## [6] &quot;Wise&quot; &quot;Conniving&quot; trojan.war[ , &quot;description&quot;] ## description ## 1: Aggressive ## 2: Loyal ## 3: Regal ## 4: Cowardly ## 5: Proud ## 6: Wise ## 7: Conniving trojan.war[[&quot;description&quot;]] ## [1] &quot;Aggressive&quot; &quot;Loyal&quot; &quot;Regal&quot; &quot;Cowardly&quot; &quot;Proud&quot; ## [6] &quot;Wise&quot; &quot;Conniving&quot; What command would you use to show information for Achilles and Hector only? #There are several ways to do this. Here are a few: trojan.war[c(1,2)] ## person age description ## 1: Achilles 21 Aggressive ## 2: Hector 26 Loyal trojan.war[1:2] ## person age description ## 1: Achilles 21 Aggressive ## 2: Hector 26 Loyal #A more advanced way that doesn&#39;t require knowing the order of the rows: trojan.war[person %in% c(&quot;Achilles&quot;, &quot;Hector&quot;)] ## person age description ## 1: Achilles 21 Aggressive ## 2: Hector 26 Loyal What command would you use to display the person and description columns for Apollo, Athena and Aphrodite only? #There are many ways to do this. Here are a few: trojan.war[c(5, 6, 7), c(1, 3)] ## person description ## 1: Apollo Proud ## 2: Athena Wise ## 3: Aphrodite Conniving trojan.war[5:7, c(&quot;person&quot;, &quot;description&quot;)] ## person description ## 1: Apollo Proud ## 2: Athena Wise ## 3: Aphrodite Conniving #advanced method trojan.war[person %in% c(&quot;Apollo&quot;, &quot;Athena&quot;, &quot;Aphrodite&quot;), c(&quot;person&quot;, &quot;description&quot;)] ## person description ## 1: Apollo Proud ## 2: Athena Wise ## 3: Aphrodite Conniving By now you're probably tired of this data set. A passenger manifest for the Titanic is stored at http://www.ditraglia.com/econ103/titanic3.csv. Read this file and store it in a dataframe called titanic. titanic = fread(&quot;http://www.ditraglia.com/econ103/titanic3.csv&quot;) Calculate the product of all the even numbers between 2 and 18, inclusive. x = seq(2, 18, 2) x ## [1] 2 4 6 8 10 12 14 16 18 prod(x) ## [1] 185794560 The column survived in the titanic data has a value of \"1\" to indicate that the passenger in that row survived the disaster. Display only the rows of titanic corresponding to passengers that survived. titanic[survived == 1] ## pclass survived name sex ## 1: 1 1 Allen, Miss. Elisabeth Walton female ## 2: 1 1 Allison, Master. Hudson Trevor male ## 3: 1 1 Anderson, Mr. Harry male ## 4: 1 1 Andrews, Miss. Kornelia Theodosia female ## 5: 1 1 Appleton, Mrs. Edward Dale (Charlotte Lamson) female ## --- ## 496: 3 1 Turkula, Mrs. (Hedwig) female ## 497: 3 1 Vartanian, Mr. David male ## 498: 3 1 Whabee, Mrs. George Joseph (Shawneene Abi-Saab) female ## 499: 3 1 Wilkes, Mrs. James (Ellen Needs) female ## 500: 3 1 Yasbeck, Mrs. Antoni (Selini Alexander) female ## age sibsp parch ticket fare cabin embarked boat body ## 1: 29.00 0 0 24160 211.3375 B5 S 2 NA ## 2: 0.92 1 2 113781 151.5500 C22 C26 S 11 NA ## 3: 48.00 0 0 19952 26.5500 E12 S 3 NA ## 4: 63.00 1 0 13502 77.9583 D7 S 10 NA ## 5: 53.00 2 0 11769 51.4792 C101 S D NA ## --- ## 496: 63.00 0 0 4134 9.5875 S 15 NA ## 497: 22.00 0 0 2658 7.2250 C 13 15 NA ## 498: 38.00 0 0 2688 7.2292 C C NA ## 499: 47.00 1 0 363272 7.0000 S NA ## 500: 15.00 1 0 2659 14.4542 C NA ## home.dest ## 1: St Louis, MO ## 2: Montreal, PQ / Chesterville, ON ## 3: New York, NY ## 4: Hudson, NY ## 5: Bayside, Queens, NY ## --- ## 496: ## 497: ## 498: ## 499: ## 500: The column sex in the titanic data indicates each passenger's sex. Display only the rows of titanic corresponding to men. titanic[sex == &#39;male&#39;] ## pclass survived name sex age sibsp ## 1: 1 1 Allison, Master. Hudson Trevor male 0.92 1 ## 2: 1 0 Allison, Mr. Hudson Joshua Creighton male 30.00 1 ## 3: 1 1 Anderson, Mr. Harry male 48.00 0 ## 4: 1 0 Andrews, Mr. Thomas Jr male 39.00 0 ## 5: 1 0 Artagaveytia, Mr. Ramon male 71.00 0 ## --- ## 839: 3 0 Yousif, Mr. Wazli male NA 0 ## 840: 3 0 Yousseff, Mr. Gerious male NA 0 ## 841: 3 0 Zakarian, Mr. Mapriededer male 26.50 0 ## 842: 3 0 Zakarian, Mr. Ortin male 27.00 0 ## 843: 3 0 Zimmerman, Mr. Leo male 29.00 0 ## parch ticket fare cabin embarked boat body ## 1: 2 113781 151.5500 C22 C26 S 11 NA ## 2: 2 113781 151.5500 C22 C26 S 135 ## 3: 0 19952 26.5500 E12 S 3 NA ## 4: 0 112050 0.0000 A36 S NA ## 5: 0 PC 17609 49.5042 C 22 ## --- ## 839: 0 2647 7.2250 C NA ## 840: 0 2627 14.4583 C NA ## 841: 0 2656 7.2250 C 304 ## 842: 0 2670 7.2250 C NA ## 843: 0 315082 7.8750 S NA ## home.dest ## 1: Montreal, PQ / Chesterville, ON ## 2: Montreal, PQ / Chesterville, ON ## 3: New York, NY ## 4: Belfast, NI ## 5: Montevideo, Uruguay ## --- ## 839: ## 840: ## 841: ## 842: ## 843: This is the first of many terrible puns you will encounter in this book.↩︎ "],["using-webexercises.html", "Lesson 2 Using webexercises 2.1 Tally the number of correct answers: total_correct() 2.2 Create a TRUE/FALSE question: torf() 2.3 Create fill-in-the-blank Questions: fitb() 2.4 Create a multiple choice question: mcq(), mcqlong() 2.5 Hide Solutions / Create Hints", " Lesson 2 Using webexercises Let's take a look at some of the tools that webexercises provides us. It can be used to tally up the number of correct answers: total_correct() create TRUE/FALSE questions: torf() create fill-in-the-blank questions: fitb() create multiple choice questions: mcq() or longmcq() hide solutions / create hints: hide(), unhide(), or webex.hide = TRUE We'll now examine each of these possibilities in detail. 2.1 Tally the number of correct answers: total_correct() Suppose that you want to keep track of how many questions a user has answered correctly so far. You can do this with the total_correct() function. The elem and args arguments control formatting: elem is used to set header styles, say you wanted h3 instead of h2, and args feeds in raw CSS if you want to make manual tweaks: It doesn't matter where you put total_correct() in your document: it will still work as expected. In this document, for example, it appears near the top. Nevertheless, as you work down to the bottom and answer more questions, the tally will update dynamically. 2.2 Create a TRUE/FALSE question: torf() Supply the correct answer as the first argument to torf(). This should either be TRUE or FALSE, e.g. True or False: \\(\\pi\\) is a rational number. TRUEFALSE 2.3 Create fill-in-the-blank Questions: fitb() As with torf(), supply the correct answer as the first argument of fitb(). The difference is that fitb() allows you to supply something other than TRUE or FALSE as the correct answer, and displays a text field rather than a drop-down menu: \\(8 \\times 9 =\\) This correct answer doesn't have to be hard-coded: you can do calculations in place or supply the name of an R object created elsewhere in your RMarkdown document. This allows you to create a dynamic question and answer. Here's an example in which the question is randomly generated when you knit this document: The square root of 64 is: If the correct answer is E, but a user enters e, this will be marked as incorrect: fitb() is case sensitive. To turn this off, set ignore_case = TRUE. What is the letter after D? By default fitb() ignores whitespace. For example, rnorm ( 3 ) is counted as a correct answer to the following: Write R code to make three independent standard normal draws. If you want fitb() to treat whitespace as meaningful, set ignore_ws = TRUE. Some fill-in-the-blank questions have more than one correct answer. To create such a question, simply supply a vector as the first argument to fitb(): Type a vowel: Want to do something more complicated? No problem! You can supply regular expressions as a solution to fitb() as follows: Type any 3 letters: Here's an example with multiple correct answers to a coding question: How do you load the tidyverse package? I'm not clear on what the width argument does. Look it up! 2.4 Create a multiple choice question: mcq(), mcqlong() Use mcq() to create a \"short\" multiple choice question. The first argument is a vector of answers in which the correct answer is given the name answer and all other elements are un-named, e.g. c('Harris', 'Trump', answer = 'Biden', 'Clinton') in the following: Who was elected president of the United States in November 2020? HarrisTrumpBidenClinton To create a multiple choice question with radio buttons rather than a dropdown menu, use mcqlong(). This tends to result in nicer formatting than a drop-down if the answers to your question are \"long,\" hence the name of the function. When your answers are long, inline R code can be hard to read. To avoid this problem, you can set up your multiple choice answers in a vector within an R chunk with echo=FALSE and then supply that vector as the first argument to longmcq() in an inline R chunk. For example: Which of these statements about p-values is correct? A p-value is the probability that the null hypothesis is true A p-value is the probability of observing a test statistic at least as extreme as the one we actually observed, assuming that the null hypothesis is true. The p-value is the probability of making a mistake when testing a hypothesis. What is true about a 95% confidence interval for the population mean \\(\\mu\\)? The probability that \\(\\mu\\) lies in our confidence interval equals 0.95. Approximately 95% of the values in our dataset will fall within the confidence interval. If we repeatedly draw a sample of the same size from the same population, and construct an interval in this way for each sample, then approximately 95% of the intervals will contain \\(\\mu\\). 2.5 Hide Solutions / Create Hints This is the main piece of functionality that I was hoping to use for my Core ERM course: hiding hints and solutions to exercises and providing buttons that students can click to reveal them. There are two ways to do this: inline, and using R chunks. For inline hints and solutions, put hide() before and unhide() after the hint or solution. Each of these should be inserted as inline R code. Provide a text string as an argument to hide() to control the text displayed on the button. Here's an example: 2.5.1 Example 1: Inline Hint and Solution Make a histogram of 100 independent standard normal draws. Show Hint Look at the R help functions for rnorm() and hist(). Show Solution hist(rnorm(100)) The hide/unhide patter is most useful for hints, where you don't actually want to run any code, and only want to display a sentence or two. For solutions, whether or not you want to run them, it's you'll probably want to use an R chunk. To do this, set the webex.hide option to TRUE. Alternatively you can set webex.hide = 'Your Text Here' to control the text that appears on the button. For a solution that doesn't evaluate, set eval = FALSE. 2.5.2 Example 2: Chunk solution that doesn't execute Show Solution x &lt;- rnorm(100) hist(x) 2.5.3 Example 3: Chunk solution that evaluates Show Solution x &lt;- rnorm(100) hist(x) Sometimes you may want to start by both explaining the exercise and showing the desired output, while hiding the code used to generate it. To avoid re-typing code, create a named chunk with the chunk option echo = FALSE. This chunk will display the output only, not the code used to generate it. Then create an empty chunk below it with the same name but set eval = FALSE and webex.hide=TRUE or webex.hide='Your Text Here'. For this second chunk don't set echo = FALSE. 2.5.4 Example 4: Show the output, hide the code The mtcars dataset contains the following variables: head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Write code to generate the following plot using this dataset: Show Solution plot(mpg ~ disp, data = mtcars, main = &quot;Fuel Efficiency (mpg) versus Engine Displacement (cc)&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
